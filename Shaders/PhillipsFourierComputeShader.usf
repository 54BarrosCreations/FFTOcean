#include "/Engine/Private/Common.ush"
#include "Common.ush"

RWTexture2D<float4> OutputPhillipsFourierTexture;
Texture2D<float4> InputGaussianNoiseTexture;

[numthreads(32, 32, 1)]
void ComputePhillipsFourier(uint3 ThreadId : SV_DispatchThreadID)
{
    const float L = 1000.0;
    const float MinH = -4000.0;
    const float MaxH = 4000.0;
    const float WaveAmplitude = PhillipsFourierUniform.WaveAmplitude;
    const float2 WindSpeed = PhillipsFourierUniform.WindSpeed;
    
    DECLARE_TEXTURE_SIZE_WITH_NAME(InputGaussianNoiseTexture, NoiseTextureSize)
    DECLARE_TEXTURE_SIZE_WITH_NAME(OutputPhillipsFourierTexture, FourierTextureSize)
    
    InputGaussianNoiseTexture.GetDimensions(NoiseTextureSize.x, NoiseTextureSize.y);
    OutputPhillipsFourierTexture.GetDimensions(FourierTextureSize.x, FourierTextureSize.y);
    
    float WindVelocity = length(WindSpeed);
    float2 WindDirection = normalize(WindSpeed);
    float L_ = SQUARE(WindVelocity) / GRAVITY;
    
    float2 K = TWO_PI * (ThreadId.xy - FourierTextureSize / 2) / L;
    float2 Kn = normalize(K);
    float2 KnMinus = normalize(-K);
    
    float K2 = max(dot(K, K), 0.0001);
    float K4 = SQUARE(K2);
    float K2L2 = K2 * SQUARE(L_);
    
    float KnDotW      = dot(Kn, WindDirection);
    float KnMinusDotW = dot(KnMinus, WindDirection);
    
    float H0K      = clamp(sqrt((WaveAmplitude / K4) * SQUARE(KnDotW)      * exp(-1 / K2L2) * exp(-K2 * SQUARE(L / 2000))) * HALF_SQRT_TWO, MinH, MaxH);
    float H0MinusK = clamp(sqrt((WaveAmplitude / K4) * SQUARE(KnMinusDotW) * exp(-1 / K2L2) * exp(-K2 * SQUARE(L / 2000))) * HALF_SQRT_TWO, MinH, MaxH);
    
    int2 NoiseTexturePos = (ThreadId.xy / FourierTextureSize) * NoiseTextureSize;
    float4 GaussianRandom = InputGaussianNoiseTexture.Load(int3(NoiseTexturePos, 0));
    
    OutputPhillipsFourierTexture[ThreadId.xy] = float4(H0K * GaussianRandom.rg, H0MinusK * GaussianRandom.ba);
}